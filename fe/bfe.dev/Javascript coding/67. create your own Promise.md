
---
done: false
created_time: "2023-01-14 03:08"
---

mediumÂ Â 1456 accepted / 9754 tried

[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "null")Â is widely used nowadays, hard to think how we handledÂ [Callback Hell](http://callbackhell.com/ "null")Â in the old times.

Can you implement aÂ `MyPromise`Â Class by yourself?

At least it should match following requirements

1.  new promise:Â `new MyPromise((resolve, reject) => {})`
2.  chaining :Â `MyPromise.prototype.then()`Â _[then handlers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then "null")Â should be called asynchronously_
3.  rejection handler:Â `MyPromise.prototype.catch()`
4.  static methods:Â `MyPromise.resolve()`,Â `MyPromise.reject()`.

This is a challenging problem. Recommend you read about Promise thoroughly first.





## The Constructor ofÂ `MyPromise`

TheÂ `promise`Â object created by the classÂ `Promise`Â has aÂ `state`Â property. TheÂ `state`Â is initiallyÂ `pending`. So in the constructor of theÂ `MyPromise`Â class, I need to define a propertyÂ `state`Â and set it toÂ `pending`.

```js
class MyPromise {
  constructor() {
    this.state = 'pending';
  }
}
```

## Handling the function that is passed toÂ `new Promise`

The function is called theÂ **executor**. It is executed immediately and automatically byÂ `new Promise`Â and is able toÂ `resolve`Â orÂ `reject`Â the promise. So I should call it in theÂ `constructor`Â of theÂ `MyPromise`Â class with the argumentsÂ `resolve`Â andÂ `reject`.

ðŸ™‹â€â™€ï¸ðŸ™‹â€â™‚ï¸ Error thrown by the executor function should be handled. If there is an error, the promise should be rejected.

```js
class MyPromise {
  constructor(executor) {
    // ...
    try {
      executor(/* resolve */, /* reject */);
    } catch (error) {
      // reject the promise
    }
  }
}
```

## ImplementingÂ `resolve`Â andÂ `reject`Â that are passed to the executor function

A executor function that resolves the promise looks like this:

```js
function(resolve, reject) {
  setTimeout(() => {
    resolve('Done!');
  }, 1000);
}
```

A executor function that rejects the promise looks like this:

```js
 function(resolve, reject) {
  setTimeout(() => {
    reject(new Error('Something went wrong!'));
  }, 1000);
}
```

`resolve`Â andÂ `reject`Â are both functions which receive one argument. So I should define the two methods in the classÂ `MyPromise`.

WhenÂ `resolve`Â is called, theÂ `state`Â of theÂ `promise`Â is changed toÂ `fulfilled`; whenÂ `reject`Â is called, theÂ `state`Â is changed toÂ `rejected`.

Besides theÂ `state`Â property, theÂ `promise`Â object should also have aÂ `result`Â property to store the promise result. Initially, it is set toÂ `undefined`. Its value changes either to the resolved value ifÂ `resolve(value)`Â is called, or to the rejected value ifÂ `reject(error)`Â is called.

AÂ `Promise`Â can only be resolved or rejected once.

Thus, I can define myÂ `resolve`Â andÂ `reject`Â like the following:

```js
_resolve(value) {
  // Ensure Promise is only resolved or rejected once.
  if (this.state !== 'pending') return;

  this.state = 'fulfilled';
  this.result = value;
}

_reject(error) {
  // Ensure Promise is only resolved or rejected once.
  if (this.state !== 'pending') return;

  this.state = 'rejected';
  this.result = error;
}
```

SinceÂ `MyPromise`Â will also have two static methodsÂ `resolve`Â andÂ `reject`, use underscores to differentiate them.

Because class methods are not bound by default andÂ `_resolve`Â orÂ `_reject`Â will be called in the executor function with a plain, undecorated function reference,Â `this`Â inside both methods will be lost. Therefore I need toÂ `bind`Â both methods in theÂ `constructor`Â or use the experimental fat arrow class methods.

## ImplementingÂ `then`Â method

`Promise.prototype.then()`Â takes up to two arguments:

1.  The first argument is a function that is invoked when the promise is resolved, and receives the result. If it is not a function, it is replaced with a function that simply returns the received result.
2.  The second argument is a function that runs when the promise is rejected, and receives the error. If it is not a function, it is replaced with a "Thrower" function.

The syntax is:

```js
promise.then(
  (result) => {
    // handle a successful result
  },
  (error) => {
    // handle an error
  }
);
```

Both arguments are optional.

TheÂ `Promise.prototype.then()`Â returns aÂ `Promise`:

```js
const promise = Promise.resolve('from promise');
const thenPromise = promise.then((result) => {});

console.log(promise);
// Promise {
//   [[PromiseState]]: 'fulfilled',
//   [[PromiseResult]]: 'from promise',
// }
console.log(thenPromise);
// Promise {
//   [[PromiseState]]: 'pending',
//   [[PromiseResult]]: undefined,
// }

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'fulfilled',
//   [[PromiseResult]]: undefined,
// }
```

So theÂ `then`Â method of the classÂ `MyPromise`Â should be look like this:

```js
then(onFulfilled, onRejected) {
  return new MyPromise((resolve, reject) => {});
}
```

### Handling the first argument in myÂ `then`Â method

Since the callback function runs when the promise is resolved, it cannot be executed within theÂ `then`. For example:

```js
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    try {
      executor(this._resolve.bind(this), this._reject.bind(this));
    } catch (error) {
      this._reject(error);
    }
  }

  _resolve(result) {
    // ...
    this.state = 'fulfilled';
    this.result = result;
  }

  then(onFulfilled) {
    onFulfilled(this.result);
    // Call onFulfilled asynchronously.
    // queueMicrotask(() => {
    //   onFulfilled(this.result);
    // });
  }
}

const p = new MyPromise((resolve) => {
  resolve(10);
}).then((result) => {
  console.log(result); // 10
});
```

Although the code above seems to work, it doesn't work as intended when the promise is resolved asynchronously, even if theÂ `onFulfilled`Â is called asynchronously:

```js
const p = new MyPromise((resolve) => {
  setTimeout(() => {
    resolve(10);
  }, 0);
}).then((result) => {
  console.log(result); // undefined
});
```

Therefore, theÂ `onFulfilled`Â function should be called in theÂ `_resolve`Â method, and theÂ `then`Â method just registers theÂ `onFulfilled`Â function. TheÂ `onFulfilled`Â function is like a subscriber, subscribing to the promised result, and theÂ `then`Â method is kind of like the functionÂ `subscribe`Â in the Publisher/Subscriber Pattern, which receives subscriber callbacks and stores/registers them in certain data structures.

```js
class MyPromise {
  constructor(executor) {
    // ...
  }

  _resolve(value) {
    //...
    this.onFulfilled(this.result);
  }

  then(onFulfilled) {
    // If onFulfilled is not a function, replace it with a function
    // that simply returns the received result.
    const isOnFulfilledFunction = typeof onFulfilled === 'function';
    this.onFulfilled = isOnFulfilledFunction ? onFulfilled : (value) => value;

    return new Promise((resolve, reject) => {});
  }
}
```

Although theÂ `then`Â method will be triggered instantly, the callback functions (handlers) will be invoked asynchronously.Â `Promise`Â uses the microtask queue to run the callbacks. When a promise is settled, itsÂ `.then`Â handlers are add into the microtask queue. Immediately after everyÂ _macrotask_, all tasks fromÂ _microtask_Â queue get executed, prior to any other macrotask runs.

```js
console.log('Start!');

setTimeout(() => {
  console.log('Timeout!');
}, 0);

Promise.resolve('Promise!').then((result) => {
  console.log(result);
});

console.log('End!');

// Logs, in order:
// 'Start!'
// 'End!'
// 'Promise!'
// 'Timeout!'
```

To queue an function for execution in the microtask queue, I can use the functionÂ [queueMicrotask()](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask).

```js
_resolve(value) {
  //...
  queueMicroTask(() => {
    this.onFulfilled(this.result);
  });
}
```

Next, I need to handle the return value returned by theÂ `onFulfilled`Â function. In theÂ `Promise`, if theÂ `onFulfilled`Â function:

-   returns a value, the promise returned byÂ `then`Â gets resolved with the returned value as its value.

```js
const promise = Promise.resolve('from promise');

const thenPromise = promise.then((result) => {
  return 'from then handler';
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'fulfilled',
//   [[PromiseResult]]: 'from then handler',
// }
```

-   doesn't return anything, the promise returned byÂ `then`Â gets resolved with anÂ `undefined`Â value.

```js
const promise = Promise.resolve('from promise');

const thenPromise = promise.then((result) => {
  console.log(result); // 'from promise'
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'fulfilled',
//   [[PromiseResult]]: undefined,
// }
```

-   throws an error, the promise returned byÂ `then`Â gets rejected with the error as its value.

```js
const promise = Promise.resolve('from promise');

const thenPromise = promise.then((result) => {
  throw new Error('error from then handler');
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'rejected',
//   [[PromiseResult]]: Error: error from then handler.
// }
```

-   returns an already fulfilled promise, the promise returned byÂ `then`Â gets resolved with that promise's value as its value.

```js
const promise = Promise.resolve('from promise');

const thenPromise = promise.then((result) => {
  return Promise.resolve('resolved promise returned by then handler');
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'fulfilled',
//   [[PromiseResult]]: 'resolved promise returned by then handler',
// }
```

-   returns an already rejected promise, the promise returned byÂ `then`Â gets rejected with that promise's value as its value.

```js
const promise = Promise.resolve('promise');

const thenPromise = promise.then((result) => {
  return Promise.reject('rejected promise returned by then handler');
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'rejected',
//   [[PromiseResult]]: 'rejected promise returned by then handler',
// }
```

-   returns aÂ **pending**Â promise, the promise returned byÂ `then`Â gets resolved or rejected after the the promise returned by the handler gets resolved or rejected. The resolved value of the promise returned byÂ `then`Â will be the same as the resolved value of the promise returned by the handler.

```js
const promise = Promise.resolve('promise');

const thenPromise = promise.then((result) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('resolved promise returned by then handler');
    }, 3000);
  });
});

setTimeout(() => {
  console.log(thenPromise); // Promise {<pending>}
});

setTimeout(() => {
  console.log(thenPromise);
  // Promise {<fulfilled>: "resolved promise returned by then handler"}
}, 4000);
```

Therefore, I need to make theÂ `resolve`Â andÂ `reject`Â of the promise returned byÂ `then`Â available inÂ `_resolve`Â method, so that they can be invoked after theÂ `onFulfilled`Â function is completed and receive the value returned by theÂ `onFulfilled`Â function. We can create two properties in current promise object to store both functions:

```js
then(onFulfilled) {
  // ...
  return new Promise((resolve, reject) => {
    this.thenPromiseResolve = resolve;
    this.thenPromiseReject = reject;
  });
}
```

InÂ `_resolve`Â I can useÂ `try...catch`Â to catch the error thrown by theÂ `onFulfilled`Â method. In theÂ `catch`Â block, callÂ `this.thenPromiseReject()`Â with the error as argument to reject the promise returned byÂ `then`. In theÂ `try`Â block, store the value returned by theÂ `onFulfilled`Â method. If the returned value is a promise, the promise returned byÂ `then`Â will only get fulfilled or rejected once that promise gets resolved or rejected. To accomplish this, I can call theÂ `then`Â method of the returned value and passÂ `this.thenPromiseResolve()`Â andÂ `this.thenPromiseReject()`Â as theÂ `then`Â handlers. If the return value is not a promise, callÂ `this.thenPromiseResolve()`Â with the return value as argument to resolve the promise returned byÂ `then`.

```js
_resolve(value) {
  // ...
  queueMicroTask(() => {
    try {
      const returnValue = this.onFulfilled(this.result);
      const isReturnValuePromise = returnValue instanceof MyPromise;

      if (!isReturnValuePromise) {
        this.thenPromiseResolve(returnValue);
      } else {
        returnValue.then(
          this.thenPromiseResolve,
          this.thenPromiseReject,
        );
      }
    } catch (error) {
      this.thenPromiseReject(error);
    }
  });
}
```

In addition, before I callÂ `this.onFulfilled`, I also need to ensure it is notÂ `undefined`, sinceÂ `.then()`Â might not be called:

```js
const promise = Promise.resolve('foo');

promise.then((result) => {
  return 'bar';
});
// The promise returned by `then` is resolved, but there
// is no further action with the promise. Therefore, when
// the method `_resolve` of the returned promise runs,
// `this.onFulfilled` is undefined.
```

Add the check:

```js
_resolve(value) {
  // ...
  queueMicroTask(() => {
    if (this.onFulfilled === undefined) return;

    // ...
  });
}
```

### Handling the second argument in myÂ `then`Â method

The second callback function runs when the promise is rejected. Like the first argument,Â `then`Â should register the second callback function, so thatÂ `_reject`Â can execute it asynchronously whenever the promise is rejected.

```js
then(onFulfilled, onRejected) {
  // ...
  this.onRejected = onRejected;
  // ...
}
```

```js
_reject(error) {
  // ...
  queueMicrotask(() => {
    try {
      this.onRejected(error);
    } catch (error) {

    }
  })
}
```

Now I need to handle the consequences of callingÂ `onRejected`. In theÂ `Promise`, if theÂ `onRejected`Â :

-   is not a function, theÂ `onRejected`Â is replaced with a function that throws the received argument, and the promise returned byÂ `then`Â gets rejected with that promise's value as its value.

```js
const promise = Promise.reject('error from promise');

const thenPromise = promise.then((result) => {});

setTimeout(() => {
  console.log(thenPromise);
});
// Uncaught (in promise) error from promise
// Promise {
//   [[PromiseState]]: 'rejected',
//   [[PromiseResult]]: 'error from promise',
// }
```

-   throws an error, the promise returned byÂ `then`Â gets rejected with the thrown error as its value.

```js
const promise = Promise.reject('error from promise');

const thenPromise = promise.then(null, (reason) => {
  throw new Error('Error from onRejected');
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'rejected',
//   [[PromiseResult]]: Error: Error from onRejected
// }
```

-   doesn't return anything, the promise returned byÂ `then`Â gets resolved with anÂ `undefined`Â value.

```js
const promise = Promise.reject('error from promise');

const thenPromise = promise.then(null, (reason) => {
  console.log(reason);
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'fulfilled',
//   [[PromiseResult]]: undefined
// }
```

-   returns a value, the promise returned byÂ `then`Â gets resolved with the returned value as its value.

```js
const promise = Promise.reject('error from promise');

const thenPromise = promise.then(null, (reason) => {
  return 'value returned by onRejected handler';
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'fulfilled',
//   [[PromiseResult]]: 'value returned by onRejected handler'
// }
```

-   returns an already fulfilled promise, the promise returned byÂ `then`Â gets resolved with that promise's value as its value.

```js
const promise = Promise.reject('error from promise');

const thenPromise = promise.then(null, (reason) => {
  return Promise.resolve('resolved promise returned by onRejected handler');
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'fulfilled',
//   [[PromiseResult]]: 'resolved promise returned by onRejected handler'
// }
```

-   returns an already rejected promise, the promise returned byÂ `then`Â gets rejected with that promise's value as its value.

```js
const promise = Promise.reject('error from promise');

const thenPromise = promise.then(null, (reason) => {
  return Promise.reject('rejected promise returned by onRejected handler');
});

setTimeout(() => {
  console.log(thenPromise);
});
// Promise {
//   [[PromiseState]]: 'rejected',
//   [[PromiseResult]]: 'rejected promise returned by onRejected handler'
// }
```

-   returns aÂ **pending**Â promise, the promise returned byÂ `then`Â gets resolved or rejected after the promise returned by the handler gets resolved or rejected.

```js
const promise = Promise.reject('error from promise');

const thenPromise = promise.then(null, (reason) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('resolved promise returned by onRejected handler');
    }, 3000);
  });
});

setTimeout(() => {
  console.log(thenPromise); // Promise {<pending>}
});

setTimeout(() => {
  console.log(thenPromise);
  // Promise {<fulfilled>: "resolved promise returned by onRejected handler"}
}, 4000);
```

In myÂ `then`Â method, I need to replaceÂ `onRejected`Â with a function that throws the 'value' it receives as argument.

```js
then(onFulfilled, onRejected) {
  // ...
  const isOnRejectedFunction = typeof onRejected === 'function';
  this.onRejected = isOnRejectedFunction ? onRejected : (error) => { throw error };
  // ...
}
```

And in myÂ `_reject`Â method, I first try to callÂ `this.onRejected()`Â and store its return value. If the returned value is not an instance ofÂ `MyPromise`, resolve the promise returned byÂ `then`Â by callingÂ `this.thenPromiseResolve()`Â with the returned value as argument. Otherwise call theÂ `then`Â method of the returned value withÂ `this.thenPromiseResolve()`Â andÂ `this.thenPromiseReject()`Â as arguments. Catch any errors thrown byÂ `this.OnRejected()`; callÂ `this.thenPromiseReject()`Â and pass the error. I also need to ensureÂ `this.onRejected`Â is notÂ `undefined`.

```js
_reject(error) {
  // ...
  queueMicrotask(() => {
    if (this.onRejected === undefined) return;

    try {
      const returnValue = this.onRejected(this.result);
      const isReturnValuePromise = returnValue instanceof MyPromise;

      if (!isReturnValuePromise) {
        this.thenPromiseResolve(returnValue);
      } else {
        returnValue.then(
          this.thenPromiseResolve;
          this.thenPromiseReject;
        );
      }
    } catch (error) {
      this.thenPromiseReject(error);
    }
  })
}
```

## ImplementingÂ `catch`Â method

InÂ `Promise`, we can also use theÂ `catch`Â method to handle rejected cases, and theÂ `catch`Â method also returns aÂ `Promise`.

The syntax is:

```js
const promise1 = new Promise((resolve, reject) => {
  throw 'Uh-oh!';
});

promise1.catch((error) => {
  console.error(error);
});
// expected output: Uh-oh!
```

It is exactly the same as callingÂ `Promise.prototype.then(null, errorHandlingFunction)`.Â [In fact, calling obj.catch(onRejected) internally calls obj.then(undefined, onRejected)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch).

So I can define myÂ `catch`Â method this way:

```js
catch(onRejected) {
  return this.then(null, onRejected);
}
```

## Implementing the static methodÂ `MyPromise.resolve()`

The static methodÂ `Promise.resolve()`Â returns aÂ `Promise`Â object that is resolved with a given value:

-   Resolving a string:

```js
Promise.resolve('Success').then(
  function (value) {
    console.log(value); // "Success"
  },
  function (value) {
    // not called
  }
);
```

-   Resolving anotherÂ `Promise`:

```js
const original = Promise.resolve(33);
const cast = Promise.resolve(original);
cast.then(function (value) {
  console.log('value: ' + value);
});
console.log('original === cast ? ' + (original === cast));

// logs, in order:
// original === cast ? true
// value: 33
```

[Promise.resolve() also handle the case where the value is a thenable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve#resolving_thenables_and_throwing_errors), but I don't need to cover it here.

InÂ `MyPromise.resolve`, first check if the value received is a promise; if it is a promise, return the promise; otherwise return a new instance ofÂ `MyPromise`Â and resolve the promise with the given value.

```js
static resolve(value) {
  const isValuePromise = value instanceof MyPromise;

  if (isValuePromise) {
    return value;
  }

  return new MyPromise((resolve) => {
    resolve(value);
  })
}
```

## Implementing the static methodÂ `MyPromise.reject()`

The static methodÂ `Promise.reject()`Â returns aÂ `Promise`Â object that is rejected with a given reason:

```js
Promise.reject(new Error('fail')).then(
  (result) => {
    // not called
  },
  (reason) => {
    console.log(reason); // Error: fail
  }
);
```

`MyPromise.reject()`:

```js
static reject(value) {
  return new MyPromise((_, reject) => {
    reject(value);
  });
}
```

# Solution

```js
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    try {
      executor(this._resolve.bind(this), this._reject.bind(this));
    } catch (error) {
      this._reject(error);
    }
  }

  _resolve(value) {
    if (this.state !== 'pending') return;

    this.state = 'fulfilled';
    this.result = value;

    queueMicrotask(() => {
      if (this.onFulfilled === undefined) return;

      try {
        const returnValue = this.onFulfilled(this.result);
        const isReturnValuePromise = returnValue instanceof MyPromise;

        if (!isReturnValuePromise) {
          this.thenPromiseResolve(returnValue);
        } else {
          returnValue.then(this.thenPromiseResolve, this.thenPromiseReject);
        }
      } catch (error) {
        this.thenPromiseReject(error);
      }
    });
  }

  _reject(error) {
    if (this.state !== 'pending') return;

    this.state = 'rejected';
    this.result = error;

    queueMicrotask(() => {
      if (this.onRejected === undefined) return;

      try {
        const returnValue = this.onRejected(this.result);
        const isReturnValuePromise = returnValue instanceof MyPromise;

        if (!isReturnValuePromise) {
          this.thenPromiseResolve(returnValue);
        } else {
          returnValue.then(this.thenPromiseResolve, this.thenPromiseReject);
        }
      } catch (error) {
        this.thenPromiseReject(error);
      }
    });
  }

  then(onFulfilled, onRejected) {
    // Register consuming functions.
    const isOnFulfilledFunction = typeof onFulfilled === 'function';
    this.onFulfilled = isOnFulfilledFunction ? onFulfilled : (value) => value;

    const isOnRejectedFunction = typeof onRejected === 'function';
    this.onRejected = isOnRejectedFunction
      ? onRejected
      : (error) => {
          throw error;
        };

    return new MyPromise((resolve, reject) => {
      // Register `resolve` and `reject`, so that we can
      // resolve or reject this promise in `_resolve`
      // or `_reject`.
      this.thenPromiseResolve = resolve;
      this.thenPromiseReject = reject;
    });
  }

  catch(onRejected) {
    return this.then(undefined, onRejected);
  }

  static resolve(value) {
    const isValuePromise = value instanceof MyPromise;

    if (isValuePromise) {
      return value;
    }

    return new MyPromise((resolve) => {
      resolve(value);
    });
  }

  static reject(value) {
    return new MyPromise((_, reject) => {
      reject(value);
    });
  }
}
```

# Reference

-   [Promises](https://javascript.info/promise-basics)
-   [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
-   [Promise.prototype.then()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)
-   [Promise.prototype.catch()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch)
-   [Promise.resolve()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)
-   [Promise.reject()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject)
-   [Using microtasks in JavaScript with queueMicrotask()](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide)
-   [Event loop: microtasks and macrotasks](https://javascript.info/event-loop)
-   [Microtasks](https://javascript.info/microtask-queue)